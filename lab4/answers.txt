Процесс-зомби — дочерний процесс в Unix-системе, завершивший своё выполнение, 
                но ещё присутствующий в списке процессов операционной системы, 
                чтобы дать родительскому процессу считать код завершения.

Угрозы, связанные с зомби-процессами:
    Хотя процесс-зомби не использует никаких системных ресурсов, но сохраняет свою
    запись (PID) в таблице процессов системы. Но вызывает беспокойство ограниченный
    размер таблицы процессов системы. Каждый активный процесс имеет действительную
    запись в таблице процессов системы.

    Если так или иначе будет создано очень большое количество процессов-зомби, 
    то каждый процесс-зомби будет занимать PID и запись в таблице процессов
    системы, и в таблице процессов не останется места.

    Таким образом, наличие большого количества процессов-зомби в системе может помешать
    созданию любого нового процесса, и система перейдет в несогласованное состояние
    только потому, что ни PID (идентификатор процесса), ни доступное пространство в процессе стол.

Как избавиться от zombie-процессов:
    1. Смотрим, какие есть zombie-процессы и есть ли они вообще
    2. Ищем родителей этих zombie-процессов
    3. Убиваем родителя

    P.S.: Поможет нам в этом утилита ps

    Подробнее: https://losst.pro/zombi-protsessy-linux

etext:
    etext обычно указывает на конец секции кода (текстовой секции) программы.
    Это место, где заканчивается исполняемый код программы.

edata:
    edata указывает на конец секции данных программы.
    В этой секции хранятся глобальные и статические переменные, которые содержат инициализированные данные.

end:
    end указывает на конец сегмента кучи (heap) программы.
    В этом сегменте выделяются динамические данные в процессе выполнения программы.


Системный вызов kill позволяет послать сигнал процессу или группе процессов. kill(getpid(), sig).

Функция wait приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс не завершится,
или до появления сигнала, который либо завершает текущий процесс, либо требует вызвать функцию-обработчик.
Если дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби" ("zombie")), то функция
немедленно возвращается. Системные ресурсы, связанные с дочерним процессом, освобождаются

Функция waitpid приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, указанный
в параметре pid, не завершит выполнение, или пока не появится сигнал, который либо завершает текущий
процесс либо требует вызвать функцию-обработчик. Если указанный дочерний процесс к моменту вызова функции
уже завершился (так называемый "зомби"), то функция немедленно возвращается.

Описание Функция alarm предназначена для планирования генерации сигнала SIGALARM.
Этот сигнал будет передан процессу через указанное в качестве аргумента количество секунд.

SIGALRM — применяемый в POSIX-системах сигнал по истечении времени, предварительно заданного функцией alarm()

Функция signal позволяет процессу выбрать один из нескольких способов обработки сигнала прерывания от
операционной системы. Аргумент sig — это прерывание, на которое signal отвечает; оно должно быть одной
из следующих констант манифеста, определенных в SIGNAL.

POSIX Threads — стандарт POSIX-реализации потоков (нитей) выполнения. Стандарт POSIX.1c,
Threads extensions (IEEE Std 1003.1c-1995) определяет API для управления потоками, их синхронизации и планирования.

//////////////////////////////

Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы
(например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один
процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить
доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры,
файлы, каналы связи между компьютерами и многое другое.

Поток использует то же самое пространства стека, что и процесс, а множество потоков совместно используют
данные своих состояний. Как правило, каждый поток может работать (читать и писать) с одной и той же
областью памяти, в отличие от процессов, которые не могут просто так получить доступ к памяти другого
процесса. У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.

Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса,
это изменение сразу же становится видно другим потокам этого процесса.


